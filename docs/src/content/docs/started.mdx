---
title: 快速入门
description: 学习如何开始使用 Danmaku
---

import { Tabs, TabItem } from '@astrojs/starlight/components';
import { LinkCard, CardGrid } from '@astrojs/starlight/components';

:::caution[工作正在进行中]
Danmaku 目前还没有到 `v1.0` 版本，不要使用未公开的 `API`，如果您发现任何错误或意外情况，请在 [GitHub 上创建 issues](https://github.com/imtaotao/danmu/issues/new)。
:::

Danmaku 是一个**高度可扩展，功能丰富齐全**的弹幕库，为开发者提供便捷接入和编写自定义插件的能力，满足复杂的需求同时也允许极致的定制化。

## 为什么选择 Danmaku ?

现代的视频网站或多或少的都有添加弹幕功能，弹幕可以带来一系列不同的观影体验，实现一个好用，功能齐全的弹幕库并不是一件容易的事情，市面上有很多不同的弹幕库选择，但是大多数都依赖都是基于 `Canvas` 来实现的，这导致样式的绘制会很局限，并且没有什么手段进行扩展，这对后续的迭代来说是致命的，因为换一个库来实现，成本很高。

Danmaku 基于 `CSS + DOM` 来绘制弹幕，这意味着，弹幕的运动可以基于浏览器原生的动画能力，并且 `CSS + DOM` 可以做的事情格外的多，这让不同形式的弹幕都得以存在（想象一下一个弹幕嵌入一个网页的场景）。

## 快速开始

### 安装依赖

您可以使用您喜欢的包管理器在项目的依赖项中安装 `danmu`，从而将 Danmaku 添加到您现有的项目当中：

<Tabs>
<TabItem label="npm">

```sh
npm install danmu
```

</TabItem>
<TabItem label="pnpm">

```sh
pnpm install danmu
```

</TabItem>
<TabItem label="Yarn">

```sh
yarn add danmu
```

</TabItem>
</Tabs>

或者当你在调试，快速验证的时候也可以通过 CDN 的方式导入，不过需要注意，**不要在生产环境使用此 CDN**。

```html
<script src="https://unpkg.com/danmu/dist/danmu.umd.js"></script>
```

### 初始化

Danmaku 核心包只暴露了一个 `create` 方法，用来创建一个 manager 实例，是的，我们所有的实现都是多实例的方式实现的，创建的时候传入的配置可以看配置这一章节的介绍。

```ts {9-14}
import { create } from 'danma';

// 在此处创建一个 manager 实例，可以传递配置，如果不传递使用默认的配置
const manager = create({
  ...
  // 其他配置可以看配置章节，但是 plugin 参数是需要特殊注意的，他是在创建 manager 时默认的插件
  plugin: {
    // 例如：willRender
    willRender(data) {
      console.log(data.type); // 即将要渲染的弹幕类型
      console.log(data.danmaku); // 即将要渲染的弹幕实例
      DataTransfer.prevent = true; // 设置为 true 后将阻止渲染，你可以在这里做弹幕的过滤工作
      return data;
    },
  },
})
```

### 挂载并渲染

当我们创建好了一个 manager 的时候就可以挂载到某个具体的节点上并渲染，实际上 manager 内部会启动一个定时器来轮询将内存区的弹幕来渲染出来，而轮询的时间是交由你来控制的（如果没有通过配置传递，会有一个默认的值）。

```ts
// 挂载，你需要确保挂载的节点是真实存在的
manager.mount(document.getElementById('container'));

// 然后开始渲染，
manager.startPlaying();
```

### 发送普通弹幕

当前面的一些工作准备完成之后，就可以发送弹幕了。

```ts
manager.push({
  // id 是可选的
  id: 1,
  // value 的类型可以在创建 manager 的时候通过范型来约定，可以看后面的小节
  value: '弹幕内容',
});
```

但是通过 `push` 方法来发送的弹幕可能会受到弹幕算法的影响，不会立即渲染，想象一些往一个数组里面 push 一个数据，但是消费是从数组最前端拿出数据消费的。我们可以换一个 `unshift` 方法来发送弹幕。

```ts
// 在下一次渲染轮询中，立即渲染
manager.unshift({
  id: 1,
  value: '弹幕内容',
});
```

我们在初始化 manager 的时候，可以通过 `plugin` 属性来传递默认全局插件，他的作用域是对所有的弹幕都生效，而且**包含全局和弹幕两种类型的钩子**。

不过我们在发送弹幕的时候，也可以传递弹幕自己的插件，他不包含全局插件，**作用域只对当前渲染的插件生效**，如果你需要的话，这会让你更好的来控制当前这个弹幕。

```ts
manager.push(
  { value: '弹幕内容' },
  {
    ...
    moveStart(danmaku) {
      // moveStart 钩子会在弹幕即将开始运动之前触发，你可以在这里更改弹幕的样式
      danmaku.setStyle(csskey, cssValue);
    },
  }
)
```

### 发送高级弹幕

普通弹幕会受到碰撞，渲染算法的限制，对于那些需要特殊处理的弹幕，例如，顶部弹幕，特殊位置的弹幕，则需要通过发送高级弹幕来渲染，高级弹幕不会受到碰撞算法的限制。

```ts {19-20}
manager.pushFlexibleDanmaku(
  {
    id: 1, // 可选
    value: '弹幕内容',
  },
  {
    // 可选：默认从 manager.options.times 中随机取一个值
    duration: 1000,

    // 可选：'none' | 'left' | 'right', 默认取 manager.options.direction 的值
    direction: 'none',

    // 必传：需要返回高级弹幕的位置信息
    // 单位为 px（不过你自己要将 % 换算成 px 也很简单，可以参考我们的 demo）
    position: (danmaku, box) => {
      // box api 可以参见 manager.box
      // 这会让弹幕在容器居中的位置出现，因为 direaction 为 none，所以会静止播放 1s
      return {
        x: ((box.width - danmaku.getWidth()) * x) / 100,
        y: ((box.height - danmaku.getHeight()) * y) / 100,
      };
    },

    // plugin 参数是可选的，具体可以参考普通弹幕的钩子，这里是一样的
    plugin: { ...   },
  },
);
```
